(local fennel (require :fennel))

(fn rand [n] (* (math.random) (or n 1)))
(fn nil? [x] (= nil x))
(fn number? [x] (= "number" (type x)))
(fn boolean? [x] (= "boolean" (type x)))
(fn string? [x] (= "string" (type x)))
(fn table? [x] (= "table" (type x)))
(fn function? [value] (= "function" (type value)))
(fn count [xs] (table? xs) (table.maxn xs) (not xs) 0 (length xs))
(fn empty? [xs] (= 0 (count xs)))
(fn first [xs] (when xs (. xs 1)))
(fn second [xs] (when xs (. xs 2)))
(fn last [xs] (when xs (. xs (count xs))))
(fn inc [n] (+ n 1))
(fn dec [n] (- n 1))
(fn even? [n] (= (% n 2) 0))
(fn odd? [n] (not (even? n)))
(fn keys [t] (let [result []] (when t (each [k _ (pairs t)] (table.insert result k))) result))
(fn vals [t] (let [result []] (when t (each [_ v (pairs t)] (table.insert result v))) result))
(fn kv-pairs [t] (let [result []] (when t (each [k v (pairs t)] (table.insert result [k v]))) result))
(fn run! [f xs] (when xs (let [nxs (count xs)] (when (> nxs 0) (for [i 1 nxs] (f (. xs i)))))))
(fn filter [f xs] (let [result []] (run! (fn [x] (when (f x) (table.insert result x))) xs) result))
(fn map [f xs] (let [result []] (run! (fn [x] (let [mapped (f x)] (table.insert result (if (= 0 (select "#" mapped)) nil mapped)))) xs) result))
(fn map-indexed [f xs] (map f (kv-pairs xs)))
(fn identity [x] x)
(fn reduce [f init xs] (var result init) (run! (fn [x] (set result (f result x))) xs) result)
(fn some [f xs] (var result nil) (var n 1) (while (and (nil? result) (<= n (count xs))) (let [candidate (f (. xs n))] (when candidate (set result candidate)) (set n (inc n)))) result)
(fn butlast [xs] (let [total (count xs)] (->> (kv-pairs xs) (filter (fn [[n v]] (not= n total))) (map second))))
(fn rest [xs] (->> (kv-pairs xs) (filter (fn [[n v]] (not= n 1))) (map second)))
(fn concat [...] (let [result []] (run! (fn [xs] (run! (fn [x] (table.insert result x)) xs)) [...]) result))
(fn mapcat [f xs] (concat (unpack (map f xs))))
(fn pr-str [...] (let [s (table.concat (map (fn [x] (fennel.view x {:one-line true})) [...]) " ")] (if (or (nil? s) (= "" s)) "nil" s)))
(fn str [...] (->> [...] (map (fn [s] (if (string? s) s (pr-str s)))) (reduce (fn [acc s] (.. acc s)) "")))
(fn println [...] (->> [...] (map (fn [s] (if (string? s) s (pr-str s)))) (map-indexed (fn [[i s]] (if (= 1 i) s (.. " " s)))) (reduce (fn [acc s] (.. acc s)) "") print))
(fn pr [...] (println (pr-str ...)))
(fn slurp [path silent?] (match (io.open path "r") (nil msg) nil f (let [content (f:read "*all")] (f:close) content)))
(fn spit [path content] (match (io.open path "w") (nil msg) (error (.. "Could not open file: " msg)) f (do (f:write content) (f:close) nil)))
(fn merge! [base ...] (reduce (fn [acc m] (when m (each [k v (pairs m)] (tset acc k v))) acc) (or base {}) [...]))
(fn merge [...] (merge! {} ...))
(fn select-keys [t ks] (if (and t ks) (reduce (fn [acc k] (when k (tset acc k (. t k))) acc) {} ks) {}))
(fn get [t k d] (let [res (when (table? t) (let [val (. t k)] (when (not (nil? val)) val)))] (if (nil? res) d res)))
(fn get-in [t ks d] (let [res (reduce (fn [acc k] (when (table? acc) (get acc k))) t ks)] (if (nil? res) d res)))
(fn assoc [t ...] (let [[k v & xs] [...] rem (count xs) t (or t {})] (when (odd? rem) (error "assoc expects even number of arguments after table, found odd number")) (when (not (nil? k)) (tset t k v)) (when (> rem 0) (assoc t (unpack xs))) t))
(fn assoc-in [t ks v] (let [path (butlast ks) final (last ks) t (or t {})] (assoc (reduce (fn [acc k] (let [step (get acc k)] (if (nil? step) (get (assoc acc k {}) k) step))) t path) final v) t))
(fn update [t k f] (assoc t k (f (get t k))))
(fn update-in [t ks f] (assoc-in t ks (f (get-in t ks))))
(fn constantly [v] (fn [] v))

{: rand : nil? : number? : boolean? : string? : table? : function? : count : empty? : first : second : last : inc : dec : even? : odd? : keys : vals : kv-pairs : run! : filter : map : map-indexed : some : butlast : rest : concat : mapcat : pr-str : str : println : pr : slurp : spit : merge! : merge : select-keys : get : get-in : assoc : assoc-in : update : update-in : constantly}

